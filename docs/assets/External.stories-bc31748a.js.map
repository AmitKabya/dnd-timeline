{"version":3,"file":"External.stories-bc31748a.js","sources":["../../node_modules/@dnd-kit/sortable/dist/sortable.esm.js","../../stories/components/ExternalList/ExternalListItem/index.tsx","../../stories/components/ExternalList/index.tsx","../../stories/2 - External/index.tsx"],"sourcesContent":["import React, { useMemo, useRef, useEffect, useState, useContext } from 'react';\nimport { useDndContext, getClientRect, useDroppable, useDraggable, closestCorners, getFirstCollision, getScrollableAncestors, KeyboardCode } from '@dnd-kit/core';\nimport { useUniqueId, useIsomorphicLayoutEffect, CSS, useCombinedRefs, isKeyboardEvent, subtract } from '@dnd-kit/utilities';\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */\nfunction arrayMove(array, from, to) {\n  const newArray = array.slice();\n  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n  return newArray;\n}\n\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */\nfunction arraySwap(array, from, to) {\n  const newArray = array.slice();\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n  return newArray;\n}\n\nfunction getSortedRects(items, rects) {\n  return items.reduce((accumulator, id, index) => {\n    const rect = rects.get(id);\n\n    if (rect) {\n      accumulator[index] = rect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n\nfunction isValidIndex(index) {\n  return index !== null && index >= 0;\n}\n\nfunction itemsEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction normalizeDisabled(disabled) {\n  if (typeof disabled === 'boolean') {\n    return {\n      draggable: disabled,\n      droppable: disabled\n    };\n  }\n\n  return disabled;\n}\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst horizontalListSortingStrategy = _ref => {\n  var _rects$activeIndex;\n\n  let {\n    rects,\n    activeNodeRect: fallbackActiveRect,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref;\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(rects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = rects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale\n  };\n};\n\nfunction getItemGap(rects, index, activeIndex) {\n  const currentRect = rects[index];\n  const previousRect = rects[index - 1];\n  const nextRect = rects[index + 1];\n\n  if (!currentRect || !previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n  }\n\n  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\n\nconst rectSortingStrategy = _ref => {\n  let {\n    rects,\n    activeIndex,\n    overIndex,\n    index\n  } = _ref;\n  const newRects = arrayMove(rects, overIndex, activeIndex);\n  const oldRect = rects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\nconst rectSwappingStrategy = _ref => {\n  let {\n    activeIndex,\n    index,\n    rects,\n    overIndex\n  } = _ref;\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = rects[index];\n    newRect = rects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = rects[index];\n    newRect = rects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.left - oldRect.left,\n    y: newRect.top - oldRect.top,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height\n  };\n};\n\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n  scaleX: 1,\n  scaleY: 1\n};\nconst verticalListSortingStrategy = _ref => {\n  var _rects$activeIndex;\n\n  let {\n    activeIndex,\n    activeNodeRect: fallbackActiveRect,\n    index,\n    rects,\n    overIndex\n  } = _ref;\n  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = rects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n      ...defaultScale$1\n    };\n  }\n\n  const itemGap = getItemGap$1(rects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale$1\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale$1\n  };\n};\n\nfunction getItemGap$1(clientRects, index, activeIndex) {\n  const currentRect = clientRects[index];\n  const previousRect = clientRects[index - 1];\n  const nextRect = clientRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n  }\n\n  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\n\nconst ID_PREFIX = 'Sortable';\nconst Context = /*#__PURE__*/React.createContext({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  disabled: {\n    draggable: false,\n    droppable: false\n  }\n});\nfunction SortableContext(_ref) {\n  let {\n    children,\n    id,\n    items: userDefinedItems,\n    strategy = rectSortingStrategy,\n    disabled: disabledProp = false\n  } = _ref;\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    measureDroppableContainers\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(() => userDefinedItems.map(item => typeof item === 'object' && 'id' in item ? item.id : item), [userDefinedItems]);\n  const isDragging = active != null;\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n  const disabled = normalizeDisabled(disabledProp);\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isDragging) {\n      measureDroppableContainers(items);\n    }\n  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n  const contextValue = useMemo(() => ({\n    activeIndex,\n    containerId,\n    disabled,\n    disableTransforms,\n    items,\n    overIndex,\n    useDragOverlay,\n    sortedRects: getSortedRects(items, droppableRects),\n    strategy\n  }), // eslint-disable-next-line react-hooks/exhaustive-deps\n  [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);\n  return React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nconst defaultNewIndexGetter = _ref => {\n  let {\n    id,\n    items,\n    activeIndex,\n    overIndex\n  } = _ref;\n  return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = _ref2 => {\n  let {\n    containerId,\n    isSorting,\n    wasDragging,\n    index,\n    items,\n    newIndex,\n    previousItems,\n    previousContainerId,\n    transition\n  } = _ref2;\n\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n  duration: 200,\n  easing: 'ease'\n};\nconst transitionProperty = 'transform';\nconst disabledTransition = /*#__PURE__*/CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear'\n});\nconst defaultAttributes = {\n  roleDescription: 'sortable'\n};\n\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */\n\nfunction useDerivedTransform(_ref) {\n  let {\n    disabled,\n    index,\n    node,\n    rect\n  } = _ref;\n  const [derivedTransform, setDerivedtransform] = useState(null);\n  const previousIndex = useRef(index);\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getClientRect(node.current, {\n          ignoreTransform: true\n        });\n        const delta = {\n          x: initial.left - current.left,\n          y: initial.top - current.top,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n  useEffect(() => {\n    if (derivedTransform) {\n      setDerivedtransform(null);\n    }\n  }, [derivedTransform]);\n  return derivedTransform;\n}\n\nfunction useSortable(_ref) {\n  let {\n    animateLayoutChanges = defaultAnimateLayoutChanges,\n    attributes: userDefinedAttributes,\n    disabled: localDisabled,\n    data: customData,\n    getNewIndex = defaultNewIndexGetter,\n    id,\n    strategy: localStrategy,\n    resizeObserverConfig,\n    transition = defaultTransition\n  } = _ref;\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disabled: globalDisabled,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy\n  } = useContext(Context);\n  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n  const index = items.indexOf(id);\n  const data = useMemo(() => ({\n    sortable: {\n      containerId,\n      index,\n      items\n    },\n    ...customData\n  }), [containerId, customData, index, items]);\n  const itemsAfterCurrentSortable = useMemo(() => items.slice(items.indexOf(id)), [items, id]);\n  const {\n    rect,\n    node,\n    isOver,\n    setNodeRef: setDroppableNodeRef\n  } = useDroppable({\n    id,\n    data,\n    disabled: disabled.droppable,\n    resizeObserverConfig: {\n      updateMeasurementsFor: itemsAfterCurrentSortable,\n      ...resizeObserverConfig\n    }\n  });\n  const {\n    active,\n    activatorEvent,\n    activeNodeRect,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    setActivatorNodeRef,\n    transform\n  } = useDraggable({\n    id,\n    data,\n    attributes: { ...defaultAttributes,\n      ...userDefinedAttributes\n    },\n    disabled: disabled.draggable\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy != null ? localStrategy : globalStrategy;\n  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n    rects: sortedRects,\n    activeNodeRect,\n    activeIndex,\n    overIndex,\n    index\n  }) : null;\n  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n    id,\n    items,\n    activeIndex,\n    overIndex\n  }) : index;\n  const activeId = active == null ? void 0 : active.id;\n  const previous = useRef({\n    activeId,\n    items,\n    newIndex,\n    containerId\n  });\n  const itemsHaveChanged = items !== previous.current.items;\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: previous.current.newIndex,\n    previousItems: previous.current.items,\n    previousContainerId: previous.current.containerId,\n    transition,\n    wasDragging: previous.current.activeId != null\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect\n  });\n  useEffect(() => {\n    if (isSorting && previous.current.newIndex !== newIndex) {\n      previous.current.newIndex = newIndex;\n    }\n\n    if (containerId !== previous.current.containerId) {\n      previous.current.containerId = containerId;\n    }\n\n    if (items !== previous.current.items) {\n      previous.current.items = items;\n    }\n  }, [isSorting, newIndex, containerId, items]);\n  useEffect(() => {\n    if (activeId === previous.current.activeId) {\n      return;\n    }\n\n    if (activeId && !previous.current.activeId) {\n      previous.current.activeId = activeId;\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      previous.current.activeId = activeId;\n    }, 50);\n    return () => clearTimeout(timeoutId);\n  }, [activeId]);\n  return {\n    active,\n    activeIndex,\n    attributes,\n    data,\n    rect,\n    index,\n    newIndex,\n    items,\n    isOver,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setActivatorNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform != null ? derivedTransform : finalTransform,\n    transition: getTransition()\n  };\n\n  function getTransition() {\n    if ( // Temporarily disable transitions for a single frame to set up derived transforms\n    derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n    itemsHaveChanged && previous.current.newIndex === index) {\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({ ...transition,\n        property: transitionProperty\n      });\n    }\n\n    return undefined;\n  }\n}\n\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n  var _localDisabled$dragga, _localDisabled$droppa;\n\n  if (typeof localDisabled === 'boolean') {\n    return {\n      draggable: localDisabled,\n      // Backwards compatibility\n      droppable: false\n    };\n  }\n\n  return {\n    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n  };\n}\n\nfunction hasSortableData(entry) {\n  if (!entry) {\n    return false;\n  }\n\n  const data = entry.data.current;\n\n  if (data && 'sortable' in data && typeof data.sortable === 'object' && 'containerId' in data.sortable && 'items' in data.sortable && 'index' in data.sortable) {\n    return true;\n  }\n\n  return false;\n}\n\nconst directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\nconst sortableKeyboardCoordinates = (event, _ref) => {\n  let {\n    context: {\n      active,\n      collisionRect,\n      droppableRects,\n      droppableContainers,\n      over,\n      scrollableAncestors\n    }\n  } = _ref;\n\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !collisionRect) {\n      return;\n    }\n\n    const filteredContainers = [];\n    droppableContainers.getEnabled().forEach(entry => {\n      if (!entry || entry != null && entry.disabled) {\n        return;\n      }\n\n      const rect = droppableRects.get(entry.id);\n\n      if (!rect) {\n        return;\n      }\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (collisionRect.top < rect.top) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Up:\n          if (collisionRect.top > rect.top) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Left:\n          if (collisionRect.left > rect.left) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n\n        case KeyboardCode.Right:\n          if (collisionRect.left < rect.left) {\n            filteredContainers.push(entry);\n          }\n\n          break;\n      }\n    });\n    const collisions = closestCorners({\n      active,\n      collisionRect: collisionRect,\n      droppableRects,\n      droppableContainers: filteredContainers,\n      pointerCoordinates: null\n    });\n    let closestId = getFirstCollision(collisions, 'id');\n\n    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n      closestId = collisions[1].id;\n    }\n\n    if (closestId != null) {\n      const activeDroppable = droppableContainers.get(active.id);\n      const newDroppable = droppableContainers.get(closestId);\n      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n\n      if (newNode && newRect && activeDroppable && newDroppable) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);\n        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n        const isAfterActive = isAfter(activeDroppable, newDroppable);\n        const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n          x: 0,\n          y: 0\n        } : {\n          x: isAfterActive ? collisionRect.width - newRect.width : 0,\n          y: isAfterActive ? collisionRect.height - newRect.height : 0\n        };\n        const rectCoordinates = {\n          x: newRect.left,\n          y: newRect.top\n        };\n        const newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n\nfunction isSameContainer(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\n\nfunction isAfter(a, b) {\n  if (!hasSortableData(a) || !hasSortableData(b)) {\n    return false;\n  }\n\n  if (!isSameContainer(a, b)) {\n    return false;\n  }\n\n  return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nexport { SortableContext, arrayMove, arraySwap, defaultAnimateLayoutChanges, defaultNewIndexGetter, hasSortableData, horizontalListSortingStrategy, rectSortingStrategy, rectSwappingStrategy, sortableKeyboardCoordinates, useSortable, verticalListSortingStrategy };\n//# sourceMappingURL=sortable.esm.js.map\n","import React, { CSSProperties, ReactNode } from 'react'\n\nimport classes from './ExternalListItem.module.css'\n\nimport { CSS } from '@dnd-kit/utilities'\nimport { useTimelineContext } from 'dnd-timeline'\nimport { useSortable } from '@dnd-kit/sortable'\n\nimport { ListItemDefinition } from '..'\n\ninterface ExternalListItemProps extends ListItemDefinition {\n  children: ReactNode\n}\n\nfunction ExternalListItem(props: ExternalListItemProps) {\n  const { getRelevanceFromDragEvent, millisecondsToPixels } =\n    useTimelineContext()\n\n  const {\n    attributes,\n    isDragging,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n  } = useSortable({\n    id: props.id,\n    disabled: props.disabled,\n    data: {\n      type: 'list-item',\n      duration: props.duration,\n      getRelevanceFromDragEvent,\n    },\n  })\n\n  const width = isDragging ? millisecondsToPixels(props.duration) + 'px' : ''\n\n  const style: CSSProperties = {\n    width,\n    opacity: isDragging ? 0.4 : undefined,\n    transform: CSS.Translate.toString(transform),\n    transition,\n  }\n\n  return (\n    <li\n      className={classes['item-wrapper']}\n      ref={setNodeRef}\n      style={style}\n      {...listeners}\n      {...attributes}\n      {...listeners}\n    >\n      {props.children}\n    </li>\n  )\n}\n\nexport default ExternalListItem\n","import React from 'react'\nimport classNames from 'classnames'\nimport { SortableContext } from '@dnd-kit/sortable'\n\nimport { format } from 'date-fns'\nimport { ItemDefinition, Relevance } from 'dnd-timeline'\n\nimport classes from './ExternalList.module.css'\n\nimport ExternalListItem from './ExternalListItem'\n\nconst ItemIcon = (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n  >\n    <path\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      d=\"M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15\"\n    />\n  </svg>\n)\n\nexport type ListItemDefinition = Omit<ItemDefinition, 'rowId' | 'relevance'> & {\n  duration: number\n}\n\nexport function ListItemOverlay({ relevance }: { relevance: Relevance }) {\n  return (\n    <div className={classNames(classes.item, classes['item-overlay'])}>\n      {ItemIcon}\n      <span>\n        {format(relevance.start, 'HH:mm')} - {format(relevance.end, 'HH:mm')}\n      </span>\n    </div>\n  )\n}\n\nfunction ExternalList({ listItems }: { listItems: ListItemDefinition[] }) {\n  return (\n    <SortableContext items={listItems}>\n      <ul className={classes['list']}>\n        {listItems.map((item) => (\n          <ExternalListItem\n            id={item.id}\n            key={item.id}\n            disabled={item.disabled}\n            duration={item.duration}\n          >\n            <div className={classes.item}>\n              {ItemIcon}\n              <span>{item.disabled ? 'Disabled Item' : 'List Item'}</span>\n            </div>\n          </ExternalListItem>\n        ))}\n      </ul>\n    </SortableContext>\n  )\n}\n\nexport default ExternalList\n","import React, { useCallback, useMemo, useState } from 'react'\nimport {\n  Active,\n  DragEndEvent,\n  DragMoveEvent,\n  DragOverlay,\n  DragStartEvent,\n} from '@dnd-kit/core'\nimport { arrayMove } from '@dnd-kit/sortable'\n\nimport classes from './External.module.css'\n\nimport Timeline, { ItemOverlay } from '../components/Timeline'\nimport ExternalList, { ListItemOverlay } from '../components/ExternalList'\nimport { generateItems, generateListItems, generateRows } from '../utils'\n\nimport {\n  endOfDay,\n  hoursToMilliseconds,\n  minutesToMilliseconds,\n  startOfDay,\n} from 'date-fns'\nimport {\n  Relevance,\n  Timeframe,\n  ResizeEndEvent,\n  ItemDefinition,\n  GridSizeDefinition,\n  Timeline as TimelineContext,\n} from 'dnd-timeline'\n\nconst DEFAULT_TIMEFRAME: Timeframe = {\n  start: startOfDay(new Date()),\n  end: endOfDay(new Date()),\n}\n\nexport interface ExternalWrapperProps {\n  rowCount: number\n  itemCount: number\n  listItemCount: number\n  timeframe?: Timeframe\n  disabledItemCount?: number\n  disabledRowCount?: number\n  backgroundItemCount?: number\n  generateDroppableMap?: boolean\n}\n\nfunction ExternalListWrapper(props: ExternalWrapperProps) {\n  const [timeframe, setTimeframe] = useState<Timeframe>(\n    props.timeframe || DEFAULT_TIMEFRAME\n  )\n\n  const [rows] = useState(() => [\n    ...generateRows(props.rowCount),\n    ...generateRows(props.disabledRowCount || 0, { disabled: true }),\n  ])\n\n  const [items, setItems] = useState(() => [\n    ...generateItems(props.itemCount, timeframe, rows),\n    ...generateItems(props.disabledItemCount || 0, timeframe, rows, {\n      disabled: true,\n    }),\n    ...generateItems(props.backgroundItemCount || 0, timeframe, rows, {\n      background: true,\n    }),\n  ])\n\n  const [listItems, setListItems] = useState(() => [\n    ...generateListItems(props.listItemCount),\n  ])\n\n  const [draggedItem, setDraggedItem] = useState<Active | null>(null)\n  const [draggedItemTempRelevance, setDraggedItemTempRelevance] =\n    useState<Relevance | null>(null)\n\n  const onDragStart = useCallback(\n    (event: DragStartEvent) => setDraggedItem(event.active),\n    [setDraggedItem]\n  )\n\n  const onDragCancel = useCallback(() => setDraggedItem(null), [setDraggedItem])\n\n  const onDragEnd = useCallback(\n    (event: DragEndEvent) => {\n      const overedId = event.over?.id.toString()\n      if (!overedId) return\n\n      const activeItemId = event.active.id\n\n      const overedType = event.over?.data?.current?.type\n      const activeType = event.active?.data?.current?.type\n\n      const getRelevanceFromDragEvent =\n        event.active?.data?.current?.getRelevanceFromDragEvent\n\n      const updatedRelevance = getRelevanceFromDragEvent(event)\n\n      if (\n        updatedRelevance &&\n        overedType === 'timeline-row' &&\n        activeType === 'timeline-item'\n      ) {\n        setItems((prev) =>\n          prev.map((item) => {\n            if (item.id !== activeItemId) return item\n\n            return {\n              ...item,\n              rowId: overedId,\n              relevance: updatedRelevance,\n            }\n          })\n        )\n      } else if (\n        activeItemId !== overedId &&\n        overedType === 'list-item' &&\n        activeType === 'list-item'\n      ) {\n        setListItems((prev) => {\n          const activeIndex = prev.findIndex(({ id }) => id === activeItemId)\n          const overIndex = prev.findIndex(({ id }) => id === overedId)\n          return arrayMove(prev, activeIndex, overIndex)\n        })\n      } else if (\n        updatedRelevance &&\n        overedType === 'timeline-row' &&\n        activeType === 'list-item'\n      ) {\n        setListItems((prev) =>\n          prev.filter((listItem) => listItem.id !== activeItemId)\n        )\n        setItems((prev) => {\n          const newItem: ItemDefinition = {\n            id: activeItemId.toString(),\n            rowId: overedId.toString(),\n            relevance: updatedRelevance,\n          }\n\n          return [...prev, newItem]\n        })\n      }\n\n      setDraggedItem(null)\n    },\n    [setItems, setListItems, setDraggedItem]\n  )\n\n  const onDragMove = useCallback(\n    (event: DragMoveEvent) =>\n      setDraggedItemTempRelevance(\n        event.active.data.current?.getRelevanceFromDragEvent(event)\n      ),\n    []\n  )\n\n  const onResizeEnd = useCallback(\n    (event: ResizeEndEvent) => {\n      const updatedRelevance = event.active.data.current?.relevance\n      if (!updatedRelevance) return\n\n      const activeItemId = event.active.id\n\n      setItems((prev) =>\n        prev.map((item) => {\n          if (item.id !== activeItemId) return item\n\n          return {\n            ...item,\n            relevance: updatedRelevance,\n          }\n        })\n      )\n    },\n    [setItems]\n  )\n\n  const timeframeGridSize = useMemo<GridSizeDefinition[]>(\n    () => [\n      {\n        value: hoursToMilliseconds(1),\n      },\n      {\n        value: minutesToMilliseconds(30),\n        maxTimeframeSize: hoursToMilliseconds(24),\n      },\n      {\n        value: minutesToMilliseconds(15),\n        maxTimeframeSize: hoursToMilliseconds(12),\n      },\n      {\n        value: minutesToMilliseconds(5),\n        maxTimeframeSize: hoursToMilliseconds(6),\n      },\n      {\n        value: minutesToMilliseconds(1),\n        maxTimeframeSize: hoursToMilliseconds(2),\n      },\n    ],\n    []\n  )\n\n  return (\n    <div className={classes.container}>\n      <TimelineContext\n        onDragEnd={onDragEnd}\n        onDragMove={onDragMove}\n        onResizeEnd={onResizeEnd}\n        onDragStart={onDragStart}\n        onDragCancel={onDragCancel}\n        timeframe={timeframe}\n        onTimeframeChanged={setTimeframe}\n        timeframeGridSize={timeframeGridSize}\n      >\n        <ExternalList listItems={listItems} />\n        <Timeline rows={rows} items={items} />\n        <DragOverlay\n          {...(draggedItem?.data?.current?.width && {\n            style: { width: draggedItem?.data?.current?.width + 'px' },\n          })}\n        >\n          {draggedItem?.data?.current?.type === 'timeline-item' &&\n            draggedItemTempRelevance && (\n            <ItemOverlay relevance={draggedItemTempRelevance} />\n          )}\n          {draggedItem?.data?.current?.type === 'list-item' &&\n            draggedItemTempRelevance && (\n            <ListItemOverlay relevance={draggedItemTempRelevance} />\n          )}\n        </DragOverlay>\n      </TimelineContext>\n    </div>\n  )\n}\n\nexport default ExternalListWrapper\n"],"names":["arrayMove","array","from","to","newArray","getSortedRects","items","rects","accumulator","id","index","rect","isValidIndex","itemsEqual","a","b","i","normalizeDisabled","disabled","rectSortingStrategy","_ref","activeIndex","overIndex","newRects","oldRect","newRect","ID_PREFIX","Context","React","SortableContext","children","userDefinedItems","strategy","disabledProp","active","dragOverlay","droppableRects","over","measureDroppableContainers","useDndContext","containerId","useUniqueId","useDragOverlay","useMemo","item","isDragging","previousItemsRef","useRef","itemsHaveChanged","disableTransforms","useIsomorphicLayoutEffect","useEffect","contextValue","defaultNewIndexGetter","defaultAnimateLayoutChanges","_ref2","isSorting","wasDragging","newIndex","previousItems","previousContainerId","transition","defaultTransition","transitionProperty","disabledTransition","CSS","defaultAttributes","useDerivedTransform","node","derivedTransform","setDerivedtransform","useState","previousIndex","initial","current","getClientRect","delta","useSortable","animateLayoutChanges","userDefinedAttributes","localDisabled","customData","getNewIndex","localStrategy","resizeObserverConfig","globalDisabled","sortedRects","globalStrategy","useContext","normalizeLocalDisabled","data","itemsAfterCurrentSortable","isOver","setDroppableNodeRef","useDroppable","activatorEvent","activeNodeRect","attributes","setDraggableNodeRef","listeners","setActivatorNodeRef","transform","useDraggable","setNodeRef","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","activeId","previous","shouldAnimateLayoutChanges","timeoutId","getTransition","isKeyboardEvent","_localDisabled$dragga","_localDisabled$droppa","KeyboardCode","ExternalListItem","props","getRelevanceFromDragEvent","millisecondsToPixels","useTimelineContext","style","jsx","classes","ItemIcon","ListItemOverlay","relevance","jsxs","classNames","format","ExternalList","listItems","DEFAULT_TIMEFRAME","startOfDay","endOfDay","ExternalListWrapper","timeframe","setTimeframe","rows","generateRows","setItems","generateItems","setListItems","generateListItems","draggedItem","setDraggedItem","draggedItemTempRelevance","setDraggedItemTempRelevance","onDragStart","useCallback","event","onDragCancel","onDragEnd","overedId","_a","activeItemId","overedType","_d","_c","_b","activeType","_g","_f","_e","updatedRelevance","_j","_i","_h","prev","listItem","newItem","onDragMove","onResizeEnd","timeframeGridSize","hoursToMilliseconds","minutesToMilliseconds","TimelineContext","Timeline","DragOverlay","ItemOverlay"],"mappings":"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","x_google_ignoreList":[0]}